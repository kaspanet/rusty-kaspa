use std::time::Instant;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use kaspa_addresses::{Address, Prefix, Version};
use kaspa_consensus_core::constants::{SOMPI_PER_KASPA, TX_VERSION};
use kaspa_consensus_core::hashing::sighash::SigHashReusedValuesUnsync;
use kaspa_consensus_core::subnets::SUBNETWORK_ID_NATIVE;
use kaspa_consensus_core::tx::{
    PopulatedTransaction, ScriptPublicKey, Transaction, TransactionInput, TransactionOutpoint, TransactionOutput,
    UtxoEntry,
};
use kaspa_txscript::caches::Cache;
use kaspa_txscript::opcodes::codes::OpZkPrecompile;
use kaspa_txscript::zk_precompiles::tags::ZkTag;
use kaspa_txscript::{pay_to_address_script, pay_to_script_hash_script, script_builder::ScriptBuilder, EngineFlags, TxScriptEngine};
use risc0_zkvm::sha::Digestible;
use risc0_zkvm::{default_prover, ExecutorEnv, Prover, ProverOpts};
use zk_covenant_inline_methods::{ZK_COVENANT_INLINE_GUEST_ELF, ZK_COVENANT_INLINE_GUEST_ID};
use zk_covenant_inline_core::PublicInput;

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt().with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env()).init();

    // --- Build the transaction for the guest and for verification ---
    let redeem_script = ScriptBuilder::new().add_op(OpZkPrecompile).unwrap().drain();
    let spk = pay_to_script_hash_script(&redeem_script);

    let (mut tx, _, utxo_entry) = make_mock_transaction(0, spk);

    let public_input = PublicInput {
        current_input: 0,
        prev_state: 0,
        new_state: 15,
        payload_diff: 15,
    };

    let env = ExecutorEnv::builder()
        .write_slice(bytemuck::bytes_of(&public_input))
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    let now = Instant::now();
    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove_with_opts(env, ZK_COVENANT_INLINE_GUEST_ELF, &ProverOpts::succinct()).unwrap();
    println!("Proving took {} ms", now.elapsed().as_millis());

    // extract the receipt.
    let receipt = prove_info.receipt;
    let receipt_inner = receipt.inner.succinct().unwrap();

    // The guest commits the txid of the transaction it validated.
    // We assert that it matches the txid we calculated.
    let output: &PublicInput = bytemuck::from_bytes(receipt.journal.bytes.as_slice());
    assert_eq!(output, &public_input);

    let script_precompile_inner = {
        use kaspa_txscript::zk_precompiles::risc0::inner::Inner;
        use kaspa_txscript::zk_precompiles::risc0::merkle::MerkleProof;
        Inner {
            seal: receipt_inner.seal.clone(),
            control_id: receipt_inner.control_id,
            claim: receipt_inner.claim.digest(),
            hashfn: receipt_inner.hashfn.clone(),
            verifier_parameters: receipt_inner.verifier_parameters,
            control_inclusion_proof: MerkleProof::new(
                receipt_inner.control_inclusion_proof.index,
                receipt_inner.control_inclusion_proof.digests.clone(),
            ),
        }
    };
    let journal_digest = receipt.journal.digest();
    let expected_digest = bytemuck::bytes_of(&public_input).digest();
    assert_eq!(journal_digest, expected_digest);
    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(ZK_COVENANT_INLINE_GUEST_ID).unwrap();

    // --- Now, we update the sig_script with the real proof and verify on-chain ---
    let final_sig_script = ScriptBuilder::new()
        .add_data(&borsh::to_vec(&script_precompile_inner).unwrap())
        .unwrap()
        .add_data(journal_digest.as_bytes())
        .unwrap()
        .add_data(bytemuck::cast_slice(ZK_COVENANT_INLINE_GUEST_ID.as_slice()))
        .unwrap()
        .add_data(&[ZkTag::R0Succinct as u8])
        .unwrap()
        .add_data(&redeem_script)
        .unwrap()
        .drain();

    tx.inputs[0].signature_script = final_sig_script;

    verify_zk_succinct(&tx, &utxo_entry);
    println!("ZK proof verified successfully on-chain!");
}

fn make_mock_transaction(lock_time: u64, spk: ScriptPublicKey) -> (Transaction, TransactionInput, UtxoEntry) {
    let dummy_prev_out = TransactionOutpoint::new(kaspa_hashes::Hash::from_u64_word(1), 1);
    let dummy_tx_input = TransactionInput::new(dummy_prev_out, vec![], 10, u8::MAX);
    let addr_hash = vec![1u8; 32];

    let addr = Address::new(Prefix::Testnet, Version::PubKey, &addr_hash);
    let dummy_script_public_key = pay_to_address_script(&addr);
    let dummy_tx_out = TransactionOutput::new(SOMPI_PER_KASPA, dummy_script_public_key);

    let tx = Transaction::new(
        TX_VERSION + 1,
        vec![dummy_tx_input.clone()],
        vec![dummy_tx_out.clone()],
        lock_time,
        SUBNETWORK_ID_NATIVE,
        0,
        vec![],
    );
    let utxo_entry = UtxoEntry::new(0, spk, 0, false);
    (tx, dummy_tx_input, utxo_entry)
}

fn verify_zk_succinct(tx: &Transaction, utxo_entry: &UtxoEntry) {
    let sig_cache = Cache::new(10_000);
    let reused_values = SigHashReusedValuesUnsync::new();
    let flags = EngineFlags { covenants_enabled: false }; // Covenants not needed for just OP_VERIFY_ZK

    let populated = PopulatedTransaction::new(tx, vec![utxo_entry.clone()]);
    let mut vm = TxScriptEngine::from_transaction_input(&populated, &tx.inputs[0], 0, utxo_entry, &reused_values, &sig_cache, flags);
    vm.execute().unwrap();
}
