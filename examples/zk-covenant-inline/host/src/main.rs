use std::time::Instant;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use kaspa_addresses::{Address, Prefix, Version};
use kaspa_consensus_core::constants::{SOMPI_PER_KASPA, TX_VERSION};
use kaspa_consensus_core::subnets::SUBNETWORK_ID_NATIVE;
use kaspa_consensus_core::tx::{
    ScriptPublicKey, Transaction, TransactionId, TransactionInput, TransactionOutpoint, TransactionOutput, UtxoEntry,
};
use kaspa_txscript::pay_to_address_script;
use kaspa_txscript::zk_precompiles::risc0::inner::Inner;
use kaspa_txscript::zk_precompiles::risc0::receipt_claim::compute_assert_claim;
use kaspa_txscript::zk_precompiles::risc0::Digest;
use risc0_zkvm::sha::Digestible;
use risc0_zkvm::{default_prover, ExecutorEnv, Prover, ProverOpts};
use zk_covenant_inline_methods::{ZK_COVENANT_INLINE_GUEST_ELF, ZK_COVENANT_INLINE_GUEST_ID};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt().with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env()).init();

    let (tx, _, _) = make_mock_transaction(0);
    let tx_bytes = borsh::to_vec(&tx).unwrap();
    let tx_bytes_excluding_mass_and_txid = &tx_bytes[..tx_bytes.len() - 40];
    let tx_id = tx.id();

    let env = ExecutorEnv::builder()
        .write_slice((tx_bytes_excluding_mass_and_txid.len() as u32).to_le_bytes().as_slice())
        .write_slice(&tx_bytes_excluding_mass_and_txid)
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    let now = Instant::now();
    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove_with_opts(env, ZK_COVENANT_INLINE_GUEST_ELF, &ProverOpts::succinct()).unwrap();
    println!("Proving took {} ms", now.elapsed().as_millis());

    // extract the receipt.
    let receipt = prove_info.receipt;
    let receipt_inner = receipt.inner.succinct().unwrap();
    let output = TransactionId::from_slice(receipt.journal.bytes.as_slice());
    assert_eq!(output, tx_id);

    let script_precompile_inner = {
        use kaspa_txscript::zk_precompiles::risc0::inner::Inner;
        use kaspa_txscript::zk_precompiles::risc0::merkle::MerkleProof;
        Inner {
            seal: receipt_inner.seal.clone(),
            control_id: receipt_inner.control_id,
            claim: receipt_inner.claim.digest(),
            hashfn: receipt_inner.hashfn.clone(),
            verifier_parameters: receipt_inner.verifier_parameters,
            control_inclusion_proof: MerkleProof::new(
                receipt_inner.control_inclusion_proof.index,
                receipt_inner.control_inclusion_proof.digests.clone(),
            ),
        }
    };
    let journal_digest = receipt.claim().unwrap().value().unwrap().output.value().unwrap().unwrap().journal.digest();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(ZK_COVENANT_INLINE_GUEST_ID).unwrap();
    verify_zk_succinct(script_precompile_inner, ZK_COVENANT_INLINE_GUEST_ID.into(), journal_digest);
}

fn make_mock_transaction(lock_time: u64) -> (Transaction, TransactionInput, UtxoEntry) {
    let dummy_prev_out = TransactionOutpoint::new(kaspa_hashes::Hash::from_u64_word(1), 1);
    let dummy_sig_script = vec![0u8; 65];
    let dummy_tx_input = TransactionInput::new(dummy_prev_out, dummy_sig_script, 10, 1);
    let addr_hash = vec![1u8; 32];

    let addr = Address::new(Prefix::Testnet, Version::PubKey, &addr_hash);
    let dummy_script_public_key = pay_to_address_script(&addr);
    let dummy_tx_out = TransactionOutput::new(SOMPI_PER_KASPA, dummy_script_public_key);

    let tx = Transaction::new(
        TX_VERSION + 1,
        vec![dummy_tx_input.clone()],
        vec![dummy_tx_out.clone()],
        lock_time,
        SUBNETWORK_ID_NATIVE,
        0,
        vec![],
    );
    let utxo_entry = UtxoEntry::new(0, ScriptPublicKey::default(), 0, false);
    (tx, dummy_tx_input, utxo_entry)
}

fn verify_zk_succinct(inner: Inner, image_id: Digest, journal_hash: Digest) {


    // Verify that the claim comes from the provided image id
    compute_assert_claim(inner.claim(), image_id, journal_hash).unwrap();
    inner.verify_integrity().unwrap();
}
